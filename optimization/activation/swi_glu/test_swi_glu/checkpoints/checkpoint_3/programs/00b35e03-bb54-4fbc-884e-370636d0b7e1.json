{"id": "00b35e03-bb54-4fbc-884e-370636d0b7e1", "code": "// [[[ REPLACE_START: GluSingleTilingCalculator::CalcOptBaseShape ]]]\ninline bool GluSingleTilingCalculator::CalcOptBaseShape(GluSingleTilingOptParam& optTiling) const\n{\n    uint32_t baseColLen_ = getBaseColLenUpBound(optTiling);\n    OP_LOGI(opName_, \"CalcOptBaseShape init baseColLen : %u\", baseColLen_);\n    if (MustBeSingleBaseRowLen(baseColLen_)) {\n        SaveOptBaseShape(static_cast<uint32_t>(1), baseColLen_, optTiling);\n        return true;\n    }\n\n    while(true) {\n        // colLen\u975e32B\u5bf9\u9f50\u65f6\uff0c\u6570\u636ecopy\u5230ub\u65f6\uff0c\u6bcf\u4e00\u884c\u7684\u5c3e\u90e8\u4f1a\u8865\u9f5032B\n        uint32_t baseRowlen_ = std::min(optTiling.maxTileLen / AlignUp<uint32_t>(baseColLen_, ubMinBlockLen), getBaseRowLenUpBound());\n        if (isInvalidBaseShape(baseRowlen_, baseColLen_)) {\n            OP_LOGI(opName_, \"CalcOptBaseShape baseRowln:%u or baseColLen:%u is invalid. optTotalTileNum:%lu end\",\n                    baseRowlen_, baseColLen_, optTiling.optTotalTileNum);\n            // optTotalTileNum\u6709\u6548\uff0c\u5219\u524d\u9762\u6709\u6700\u4f18\u89e3\uff0c\u8fd4\u56detrue;\u5426\u5219\u8fd4\u56defalse\n            return (optTiling.optTotalTileNum > static_cast<uint64_t>(0));\n        }\n        // \u4fdd\u5b58\u8f83\u4f18\u7684base shape\n        if (isValidTailCol(baseRowlen_, baseColLen_)) {\n            SaveOptBaseShape(baseRowlen_, baseColLen_, optTiling);\n        }\n\n        // baseColLen\u5df2\u7ecf\u5230\u8fbe\u4e0b\u9650 \u6216\u8005 baseRowlen\u5df2\u7ecf\u8fbe\u5230\u4e0a\u9650\uff0c\u65e0\u6cd5\u7ee7\u7eed\u8c03\u6574\uff0c\u7ed3\u675f\n        if (baseColLen_ <= alignPackLen || (baseRowlen_ >= getBaseRowLenUpBound())) {\n            return true; // baseColLen\u65e0\u6cd5\u7ee7\u7eed\u8c03\u6574\u4e86\uff0c\u7ed3\u675f\n        }\n        // \u7ee7\u7eed\u8c03\u6574baseColLen\n        // baseColLen\u4e3a\u82e5alignPackLen\u7684\u6574\u6570\u500d\uff0c\u5219baseColLen\u51cf\u5c111\u4e2aalignPackLen\u7684\u957f\u5ea6\n        // \u5426\u5219baseColLen\u51cf\u5c11\u5230alignPackLen\u7684\u6574\u6570\u500d\uff08\u6700\u63a5\u8fd1\u7684\uff09\n        if (baseColLen_ % alignPackLen == static_cast<uint32_t>(0)) {\n            baseColLen_ -= alignPackLen;\n        } else {\n            baseColLen_ = AlignDown<uint32_t>(baseColLen_, alignPackLen);\n        }\n    }\n}\n// [[[ REPLACE_END ]]]\n\n// [[[ REPLACE_START: GluSingleTilingCalculator::CalcTiling ]]]\nbool GluSingleTilingCalculator::CalcTiling(uint32_t totalCore, uint64_t ubSize, int32_t dtype,  platform_ascendc::SocVersion socVersion_)\n{\n    totalAvailableCore = totalCore;\n    if (!GetLengthByType(dtype, inputDTypeLen)) {\n        OP_LOGI(opName_, \"CalcTiling Unsupported input data type %d\", dtype);\n        return false;\n    }\n    ubMinBlockLen = UB_MIN_BLOCK_SIZE / inputDTypeLen; // min block size\n    cacheLineLen = L2_CACHE_LINE_SIZE / inputDTypeLen; // bandwidth max efficiency\n    alignPackLen = cacheLineLen; // \u9ed8\u8ba4512\u5bf9\u9f50\uff0c\u7b56\u7565\u53ef\u8c03\u6574\n    OP_LOGI(opName_, \"CalcTiling GetLengthByType:%u ubMinBlockLen:%u cacheLineLen:%u alignPackLen:%u\", inputDTypeLen, ubMinBlockLen, cacheLineLen, alignPackLen);\n    // Is 32-byte aligned for split colLen?\n    tilingData->set_is32BAligned(tilingData->get_colLen() % ubMinBlockLen == 0);\n    // 310p not support Non-64B\n    uint32_t blockSizeOf64B = BLOCK_SIZE_OF_64B / inputDTypeLen;\n    if (((socVersion_ == platform_ascendc::SocVersion::ASCEND310P)) && (tilingData->get_colLen() % blockSizeOf64B != 0)) {\n        OP_LOGE(opName_, \"input shape is not support Non-64B aligned\");\n        return false;\n    }\n    // \u5148\u8ba1\u7b97\u5f00\u542fdouble buffer\u7684tiling\u53c2\u6570\n    tilingData->set_isDoubleBuffer(1);\n    GluSingleTilingOptParam optTilingDb;\n    // \u5224\u65adbuffer = 2\u65f6\u662f\u5426\u8ba1\u7b97\u6210\u529f\n    if (!CalcOptTiling<Glu_Flag, 2>(ubSize, dtype, optTilingDb)) {\n        return false;\n    }\n    GluSingleTilingOptParam *optTiling = &optTilingDb;\n    // \u5982\u679cdouble buffer\u5f00\u542f\u7684tiling\u53c2\u6570\u4e2d\uff0c\u6bcf\u4e2a\u6838\u9700\u8981\u5904\u7406\u7684tileNum\u7b49\u4e8e2\uff0c\u5c1d\u8bd5\u5173\u95eddouble buffer;\n    // \u82e5\u5173\u95eddouble buffer\u540e\u53ea\u9700\u8981\u642c\u8fd01\u6b21\u6570\u636e\uff0c\u4e14\u4f7f\u7528\u7684\u6838\u6ca1\u6709\u51cf\u5c11, \u5219\u4f7f\u7528\u5173\u95eddouble buffer\u7684tiling\n    // \u5224\u65adtileNumPerCoer\u662f\u5426\u4e3a2\n    if (optTilingDb.tileNumPerCore == static_cast<uint64_t>(2)) {\n        GluSingleTilingOptParam optTilingNoDb;\n        if (CalcOptTiling<Glu_Flag, 1>(ubSize, dtype, optTilingNoDb) &&\n            (optTilingNoDb.tileNumPerCore == static_cast<uint64_t>(1)) && (optTilingNoDb.totalUsedCoreNum >= optTilingDb.totalUsedCoreNum)) {\n            optTiling = &optTilingNoDb;\n            tilingData->set_isDoubleBuffer(0);\n        }\n    }\n    // \u8bb0\u5f55\u6700\u4f18\u7684\u7ed3\u679c\n    tilingData->set_baseRowLen(optTiling->optBaseRowLen);\n    tilingData->set_baseColLen(optTiling->optBaseColLen);\n    totalUsedCoreNum_ = optTiling->totalUsedCoreNum;\n    OP_LOGI(opName_, \"CalcTilingRES baseRowLen:%u baseColLen:%u\", optTiling->optBaseRowLen, optTiling->optBaseColLen);\n    return true;\n}\n// [[[ REPLACE_END ]]]\n\n// [[[ REPLACE_START: GluSingleTilingCalculator::SaveOptBaseShape ]]]\ninline void GluSingleTilingCalculator::SaveOptBaseShape(uint32_t baseRowLen_, uint32_t baseColLen_, GluSingleTilingOptParam& optTiling) const\n{\n    uint64_t totalTileNum = DivCeil<uint64_t>(tilingData->get_rowLen(), (baseRowLen_)) * DivCeil<uint64_t>(tilingData->get_colLen(), (baseColLen_));\n    uint64_t baseSize = static_cast<uint64_t>(baseRowLen_) * baseColLen_;\n    if (baseRowLen_ == static_cast<uint32_t>(0) || baseColLen_ == static_cast<uint32_t>(0)) {\n        OP_LOGE(opName_, \"SaveOptBaseShape devide by 0 baseRowLen_:%u baseColLen_:%u\", baseRowLen_, baseColLen_);\n        return;\n    }\n    uint64_t baseTileNum = (tilingData->get_rowLen() / baseRowLen_) * (tilingData->get_colLen() / baseColLen_);\n    uint32_t totalUsedCoreNum = std::min(totalTileNum, static_cast<uint64_t>(totalAvailableCore));\n    if ((optTiling.optTotalTileNum == static_cast<uint64_t>(0)) ||\n        (totalUsedCoreNum > optTiling.totalUsedCoreNum) ||\n        ((totalUsedCoreNum == optTiling.totalUsedCoreNum) && (totalTileNum < optTiling.optTotalTileNum)) ||\n        ((totalUsedCoreNum == optTiling.totalUsedCoreNum) && (totalTileNum == optTiling.optTotalTileNum) && (baseSize > optTiling.optBaseSize)) ||\n        ((totalUsedCoreNum == optTiling.totalUsedCoreNum) && (totalTileNum == optTiling.optTotalTileNum) && (baseSize == optTiling.optBaseSize) && (baseTileNum > optTiling.optBaseTileNum))) {\n        optTiling.optBaseRowLen = baseRowLen_;\n        optTiling.optBaseColLen = baseColLen_;\n        optTiling.optTotalTileNum = totalTileNum;\n        optTiling.optBaseSize = baseSize;\n        optTiling.optBaseTileNum = baseTileNum;\n        optTiling.totalUsedCoreNum = totalUsedCoreNum;\n        optTiling.tileNumPerCore = DivCeil<uint64_t>(totalTileNum, totalUsedCoreNum);;\n    }\n}\n// [[[ REPLACE_END ]]]", "language": "unknown", "parent_id": "fc956552-3c8f-400e-aac4-112a441c4379", "generation": 0, "timestamp": 1769528202.0919068, "iteration_found": 0, "metrics": {"combined_score": 0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"island": 1}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}