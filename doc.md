# AscendC Copilot 设计文档
## 功能概述
辅助开发者完成**昇腾算子全生命周期开发与优化**，核心支持新算子开发、已有算子性能调优、跨平台算子迁移三大核心场景，聚焦AscendC算子开发体系，适配昇腾全系列硬件平台。

---

## 算子优化模块
### 1. 用户输入规范
需提供算子基础信息与运行环境参数，参数为必传项，格式与示例如下：

| 参数 | 说明 | 合法值/范围 | 示例 |
|------|------|-------------|------|
| 仓库名称 | 算子所属官方仓库 | ops-nn、ops-math、ops-transformers | ops-nn |
| 算子名称 | 具体算子标识（与仓库内命名一致） | 仓库内已存在算子名 | ge_glu_v2 |
| 输入 shape | 算子实际运行的张量形状 | 整数数组，维度与算子输入匹配 | [24, 9216, 2560] |
| 数据类型 | 算子输入输出张量类型 | float16、float32、int32、uint8 等 | float16 |
| 硬件平台 | 算子部署的昇腾硬件 | ascend910_93、ascend910b、ascend310P、ascend710 等 | ascend910b |

### 2. 标准化工作流程
```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              算子性能优化流程                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  用户输入                                                                  │
│  ┌─────────────────────────────────────────────────────────────┐          │
│  │ 仓库: ops-nn | 算子: ge_glu_v2 | Shape: [24,9216,2560]      │          │
│  │ 类型: float16 | 平台: ascend910b                           │          │
│  └─────────────────────────────────────────────────────────────┘          │
│                                     │                                        │
│                                     ▼                                        │
│ 步骤1: 测试用例生成                                                         │
│  ┌─────────────────────────────────────────────────────┐                   │
│  │ ut-LLM (测试用例生成模型)                            │                   │
│  │ 输入: 完整算子信息 + 输入Shape + 数据类型            │                   │
│  │ 输出: gen_data.py (可执行测试数据生成脚本)           │                   │
│  └─────────────────────────────────────────────────────┘                   │
│                                     │                                        │
│                                     ▼                                        │
│ 步骤2: 优化点智能检测                                                       │
│  ┌─────────────────────────────────────────────────────┐                   │
│  │ detect-LLM (优化点检测模型)                           │                   │
│  │ 输入: 算子源代码根路径                                │                   │
│  │ 核心分析逻辑:                                         │                   │
│  │  1. 扫描 op_host 目录下 *_tiling.cpp 核心文件         │                   │
│  │  2. 解析 Tiling 函数实现与参数计算逻辑                │                   │
│  │  3. 识别可优化方向（块计算、循环展开、内存访问等）    │                   │
│  │  4. 定位待优化核心函数（如 init_program）             │                   │
│  │ 输出: 待优化函数列表 + 初步优化方向建议                │                   │
│  └─────────────────────────────────────────────────────┘                   │
│                                     │                                        │
│                                     ▼                                        │
│ 步骤3: 迭代式智能演化优化                                                   │
│  ┌─────────────────────────────────────────────────────┐                   │
│  │ openevolve agent (演化优化代理)                      │                   │
│  │ 核心迭代循环（直到性能收敛）:                         │                   │
│  │  1. 基于待优化函数生成多版本代码变体                  │                   │
│  │  2. 调用昇腾编译工具链编译算子变体                    │                   │
│  │  3. 运行基准测试（加载gen_data.py生成的测试数据）     │                   │
│  │  4. 采集全维度性能数据（耗时、吞吐量、资源利用率）    │                   │
│  │  5. 基于性能指标筛选最优代码变体                      │                   │
│  │  6. 迭代优化至性能无明显提升                          │                   │
│  │ 输入: 待优化函数列表 + gen_data.py 测试脚本           │                   │
│  │ 输出: 优化后的算子代码 + 全量性能监测数据             │                   │
│  └─────────────────────────────────────────────────────┘                   │
│                                     │                                        │
│                                     ▼                                        │
│ 优化结果统一输出                                                           │
│  ┌─────────────────────────────────────────────────────┐                   │
│  │ 1. 优化后的可直接编译的算子代码文件                   │                   │
│  │ 2. 可视化性能对比报告（耗时、吞吐量、加速比）         │                   │
│  │ 3. 详细优化建议与修改说明                             │                   │
│  └─────────────────────────────────────────────────────┘                   │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3. 核心文件与数据结构说明
#### 3.1 Tiling 相关核心文件（算子优化核心）
| 文件类型 | 固定路径 | 核心作用 |
|---------|----------|----------|
| Tiling 实现文件 | `op_host/*_tiling.cpp` | 算子Tiling策略计算主逻辑，含分块、并行、内存调度等核心代码 |
| Tiling 头文件 | `op_host/*_tiling.h` | 定义Tiling数据结构、宏、函数声明，为cpp文件提供接口 |
| Tiling 测试生成脚本 | `tests/ut/op_kernel/*_data/gen_tiling.py` | 生成测试用Tiling参数，验证Tiling逻辑正确性 |
| Tiling 二进制文件 | 运行时自动生成 `tiling.bin` | 编译后生成的Tiling参数二进制，供算子运行时加载 |

#### 3.2 标准Tiling数据结构（C++）
**头文件定义模板**（*_tiling.h），适配昇腾AscendC开发规范：
```cpp
// 定义Tiling数据结构，与算子名强绑定
BEGIN_TILING_DATA_DEF(OpNameTilingData)
TILING_DATA_FIELD_DEF(int64_t, loopNum);        // 核心循环执行次数
TILING_DATA_FIELD_DEF(int64_t, blockSize);      // 单次计算的数据块大小（匹配硬件缓存）
TILING_DATA_FIELD_DEF(int64_t, coreNum);        // 算子调度使用的AI Core核数
TILING_DATA_FIELD_DEF(int64_t, tailLoopNum);    // 尾处理循环次数（解决数据对齐问题）
TILING_DATA_FIELD_DEF(uint64_t, ubAllocSize);   // UB内存分配大小（字节）
// 可根据算子需求扩展自定义Tiling参数
END_TILING_DATA_DEF;

// 注册Tiling数据类，关联算子名与Tiling结构
REGISTER_TILING_DATA_CLASS(OpName, OpNameTilingData)

// 编译时信息结构：存储硬件平台、编译参数等静态信息
struct OpNameCompileInfo {
    int32_t totalCoreNum = 0;        // 平台总可用AI Core核数
    uint64_t ubSizePlatForm = 0;     // 硬件平台UB内存总大小（字节）
    uint32_t compileMode = 0;        // 编译模式（0:调试，1:性能）
};

// 运行时Tiling参数结构：传递Tiling计算结果至算子核函数
struct TilingParam {
    int64_t loopNum = 0;
    int64_t blockSize = 0;
    int64_t coreNum = 0;
    int64_t tailLoopNum = 0;
};
```

### 4. 优化点智能检测规则
detect-LLM 模型基于昇腾硬件特性与AscendC最佳实践，聚焦**6大类核心优化方向**，精准定位算子性能瓶颈：

| 优化类别 | 核心检测目标 | 优化思路示例 |
|---------|--------------|--------------|
| 块大小优化 | blockSize/ubAllocSize 参数是否匹配硬件缓存特性 | 调整blockSize为硬件缓存行整数倍，减少缓存未命中 |
| 核数分配优化 | coreNum 与输入Shape的匹配度、并行度利用率 | 根据张量维度大小动态分配核数，提升AI Core并行利用率 |
| 数据访问优化 | 全局内存/UB内存访问是否对齐、是否存在冗余搬运 | 增加数据padding实现内存对齐，优化UB内存数据复用策略 |
| 循环逻辑优化 | loopNum/tailLoopNum 分布、循环是否可展开/合并 | 展开小循环减少分支开销，合并嵌套循环降低调度成本 |
| 缓存利用率优化 | UB内存分配是否合理、数据复用率是否偏低 | 优化UB内存分配大小，减少全局内存与UB内存的数据搬运次数 |
| TilingKey 选择优化 | 是否根据输入特征选择最优Tiling实现路径 | 为不同输入Shape/数据类型配置专属TilingKey，适配多场景 |

### 5. 标准化输出内容
优化完成后输出**3类核心产物**，可直接用于算子编译、部署与验证：
#### 5.1 优化后的算子代码文件
- 修订后的 `op_host/*_tiling.cpp`（核心优化文件）
- 若有结构变更，同步更新 `op_host/*_tiling.h`
- 配套修改的配置文件/编译脚本（如存在）
> 所有代码修改均遵循AscendC开发规范，可直接通过昇腾官方编译工具链编译。

#### 5.2 可视化性能对比报告
**固定格式模板**（含核心性能指标与优化点）：
```
┌─────────────────────────────────────────────────────────────────────────┐
│                     昇腾算子性能优化报告                                  │
├─────────────────────────────────────────────────────────────────────────┤
│ 基础信息：                                                               │
│ 算子名称: ge_glu_v2 | 所属仓库: ops-nn | 硬件平台: ascend910b            │
│ 输入Shape: [24, 9216, 2560] | 数据类型: float16 | 测试批次: 100次        │
├─────────────────────────────────────────────────────────────────────────┤
│ 核心性能指标对比：                                                       │
│  优化前平均耗时:  1.234 ms | 优化后平均耗时:  0.856 ms | 性能提升: 30.6%  │
│  优化前吞吐量:    48.23 TFLOPS | 优化后吞吐量: 69.12 TFLOPS | 提升: 43.3%│
│  优化前AI Core利用率: 65.2% | 优化后AI Core利用率: 89.7% | 提升: 24.5%    │
├─────────────────────────────────────────────────────────────────────────┤
│ 本次核心优化点：                                                         │
│  1. 块大小优化：blockSize 从 256 调整为 512，匹配ascend910b L2缓存特性    │
│  2. 核数分配优化：coreNum 从 8 调整为 16，提升张量维度并行计算效率        │
│  3. 数据对齐优化：对输入张量增加16字节padding，消除内存访问未对齐开销    │
│  4. 循环展开优化：展开内层小循环（loopNum=8），减少CPU调度分支开销        │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 5.3 代码差异说明（可选）
以**行号+修改内容**的形式展示优化前后的代码差异，清晰标注修改原因与优化思路，示例：
```
op_host/ge_glu_v2_tiling.cpp
- 第128行：int64_t blockSize = 256;
+ 第128行：int64_t blockSize = 512;  // 优化：匹配ascend910b L2缓存，提升缓存命中率
- 第145行：int64_t coreNum = 8;
+ 第145行：int64_t coreNum = 16;   // 优化：根据输入Shape[24,9216,2560]提升并行度
```

---

## 待规划模块
### 新算子开发模块
- 支持基于AscendC规范的新算子自动生成（含核函数、Tiling逻辑、测试用例）
- 适配昇腾全平台硬件特性，自动生成最优初始Tiling策略
- 提供算子开发规范检查与代码补全能力

### 算子迁移模块
- 支持跨框架算子迁移（PyTorch/TensorFlow → AscendC）
- 支持跨昇腾平台算子迁移（如ascend310P → ascend910b）
- 自动适配目标平台硬件特性，完成迁移后性能初调
